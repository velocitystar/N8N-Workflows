{
  "name": "Distortion Check - v3 Alpha Remote JSON - FIXED",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// Get all successful upload items and use their original data\nconst allItems = $input.all();\nconst totalItems = allItems.length;\n\nconsole.log('');\nconsole.log(`üéâ BATCH COMPLETED! Processed ${totalItems} files successfully`);\n\nif (totalItems === 0) {\n  console.error('‚ùå ERROR: No items received at all!');\n  return [];\n}\n\nconsole.log('üîç DEBUGGING DATA LOSS: Analyzing all items...');\nallItems.forEach((item, index) => {\n  console.log(`üì¶ Item ${index + 1}:`);\n  console.log(`   Has json: ${!!item.json}`);\n  console.log(`   Has originalConfig: ${!!item.json?.originalConfig}`);\n  if (item.json?.originalConfig) {\n    console.log(`   originalConfig keys: ${Object.keys(item.json.originalConfig)}`);\n    console.log(`   has contentUrl: ${!!item.json.originalConfig.contentUrl}`);\n    if (item.json.originalConfig.contentUrl) {\n      console.log(`   contentUrl value: ${item.json.originalConfig.contentUrl}`);\n    }\n  }\n});\n\n// Get batch info from first item - this contains the correct nextStartIndex\nconst firstItem = allItems[0];\nif (!firstItem?.json) {\n  console.error('‚ùå ERROR: No valid items found');\n  return [];\n}\n\n// Use the EXACT values calculated by Process Remote Content\nconst nextStartIndex = firstItem.json.nextStartIndex;\nconst totalContentItems = firstItem.json.totalContentItems;\nconst hasMoreBatches = firstItem.json.hasMoreBatches;\nconst currentBatch = firstItem.json.currentBatch;\nconst totalBatches = firstItem.json.totalBatches;\nconst originalConfig = firstItem.json.originalConfig;\n\nconsole.log(`üìä BATCH COMPLETION: Completed batch ${currentBatch}/${totalBatches}`);\nconsole.log(`üìä NextStartIndex: ${nextStartIndex}`);\nconsole.log(`üìä HasMoreBatches: ${hasMoreBatches}`);\nconsole.log('üîç CRITICAL DEBUG: originalConfig analysis:');\nconsole.log(`   originalConfig exists: ${!!originalConfig}`);\nif (originalConfig) {\n  console.log(`   originalConfig keys: [${Object.keys(originalConfig).join(', ')}]`);\n  console.log(`   contentUrl present: ${!!originalConfig.contentUrl}`);\n  console.log(`   contentUrl value: ${originalConfig.contentUrl}`);\n  console.log('   Full originalConfig:');\n  console.log(JSON.stringify(originalConfig, null, 2));\n} else {\n  console.log('   originalConfig is null/undefined!');\n}\n\nif (hasMoreBatches) {\n  console.log(`üîÑ Will continue to next batch from index ${nextStartIndex}`);\n} else {\n  console.log('üéä ALL BATCHES COMPLETED!');\n}\n\n// Pass through exact data from Process Remote Content - no recalculation\nreturn [{ json: {\n  hasMoreBatches: hasMoreBatches,\n  nextStartIndex: nextStartIndex,\n  currentBatch: currentBatch,\n  totalBatches: totalBatches,\n  totalContentItems: totalContentItems,\n  processedSoFar: nextStartIndex,\n  originalConfig: originalConfig\n}}];"
      },
      "id": "batch-completion-check",
      "name": "Batch Completion Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 300]
    },
    {
      "parameters": {
        "jsCode": "console.log('üèÅ All batches completed successfully!');\nreturn $input.all();"
      },
      "id": "final-completion",
      "name": "Final Completion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 100]
    },
    {
      "parameters": {
        "jsCode": "console.log('‚ùå All batches completed - workflow ending');\nreturn $input.all();"
      },
      "id": "debug-false-path",
      "name": "Debug False Path",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 100]
    },
    {
      "parameters": {
        "jsCode": "// Take the input item from Batch Completion Check\nconst inputItem = $input.item.json;\nconst config = inputItem.originalConfig;\nconst nextStartIndex = inputItem.nextStartIndex;\n\nconsole.log(`üîÑ SETUP NEXT BATCH: Starting from index ${nextStartIndex}`);\nconsole.log('üîç DEBUG: originalConfig:', JSON.stringify(config, null, 2));\n\n// Validate that we have the required originalConfig\nif (!config) {\n  console.error('‚ùå CRITICAL: originalConfig is undefined!');\n  console.error('üìã Available inputItem keys:', Object.keys(inputItem));\n  throw new Error('originalConfig is required but was not found in batch data. Check Process Remote Content node.');\n}\n\nif (!config.contentUrl) {\n  console.error('‚ùå CRITICAL: contentUrl is missing from originalConfig!');\n  console.error('üìã Available config keys:', Object.keys(config));\n  throw new Error('contentUrl is required but was not preserved in originalConfig. Check Process Remote Content node configuration.');\n}\n\n// Create new configuration for next batch with the correct startIndex\nconst newConfig = {\n  ...config,  // Preserve ALL original config values\n  startIndex: nextStartIndex  // Only override the startIndex\n};\n\nconsole.log(`üöÄ Sending to Process Remote Content:`);\nconsole.log(`üì§ contentUrl: ${newConfig.contentUrl}`);\nconsole.log(`üì§ startIndex: ${newConfig.startIndex}`);\nconsole.log(`üì§ maxItems: ${newConfig.maxItems}`);\n\nreturn [{\n  json: newConfig\n}];"
      },
      "id": "setup-next-batch",
      "name": "Setup Next Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, -200]
    },
    {
      "parameters": {
        "jsCode": "console.log('‚úÖ More batches available - continuing to next batch');\nconsole.log('üîÑ About to wait 3 seconds before next batch');\nreturn $input.all();"
      },
      "id": "debug-true-path",
      "name": "Debug True Path",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [200, -200]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "more-batches",
              "leftValue": "={{ $json.hasMoreBatches }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "more-batches-check",
      "name": "More Batches?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [400, 100]
    },
    {
      "parameters": {
        "jsCode": "console.log('üîÑ Processing more batches available...');\nreturn $input.all();"
      },
      "id": "debug-more-batches",
      "name": "Debug More Batches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 200]
    },
    {
      "parameters": {
        "jsCode": "const current = $input.item.json;\nconst uploadResult = current;\nconst publicId = uploadResult.public_id;\nconst secureUrl = uploadResult.secure_url;\nconst bytes = uploadResult.bytes || 0;\n\nconsole.log(`‚úÖ Successfully uploaded: ${current.fileName || 'audio file'}`);\nconsole.log(`üÜî Cloudinary public ID: ${publicId}`);\nconsole.log(`üìä File size: ${Math.round(bytes / 1024)} KB`);\nconsole.log('üîç DEBUG LOG SUCCESS: Checking originalConfig preservation...');\nif (current.originalConfig) {\n  console.log('   originalConfig keys:', Object.keys(current.originalConfig));\n  console.log('   contentUrl present:', !!current.originalConfig.contentUrl);\n  console.log('   contentUrl value:', current.originalConfig.contentUrl);\n} else {\n  console.log('   ‚ùå originalConfig missing from upload result!');\n}\n\nreturn $input.all();"
      },
      "id": "log-success",
      "name": "Log Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-200, 300]
    },
    {
      "parameters": {
        "jsCode": "// Check what we received from Cloudinary and merge with original data\nconst uploadResults = $input.all();\nconst originalDataItems = $('Prepare for Upload').all();\n\nconsole.log(`üîç UPLOAD CHECK: Received ${uploadResults.length} items from Cloudinary`);\nconsole.log(`üîç ORIGINAL DATA: Have ${originalDataItems.length} original items`);\n\n// Process each item and merge Cloudinary response with original data\nconst results = uploadResults.map((uploadItem, index) => {\n  const cloudinaryData = uploadItem.json;\n  const originalData = originalDataItems[index]?.json || {};\n  \n  console.log(`üì¶ Item ${index + 1}: ${originalData.fileName || 'Unknown'}`);\n  console.log('  Cloudinary Error:', cloudinaryData.error);\n  console.log('  Public ID:', cloudinaryData.public_id);\n  console.log('  Secure URL:', cloudinaryData.secure_url);\n  console.log('  Original data preserved:', !!originalData.originalConfig);\n  \n  // Check if upload was successful\n  const isSuccess = !cloudinaryData.error && cloudinaryData.public_id;\n  console.log(`  Success: ${isSuccess}`);\n  \n  // Merge original data with Cloudinary response\n  const mergedData = {\n    ...originalData,  // Preserve all original fields (originalConfig, nextStartIndex, etc.)\n    ...cloudinaryData,  // Add Cloudinary response (public_id, secure_url, etc.)\n    // Ensure fileName is preserved from original if missing from Cloudinary\n    fileName: originalData.fileName || cloudinaryData.display_name || 'unknown.wav'\n  };\n  \n  console.log('  Merged data keys:', Object.keys(mergedData));\n  console.log('  originalConfig preserved:', !!mergedData.originalConfig);\n  if (mergedData.originalConfig) {\n    console.log('  contentUrl preserved:', !!mergedData.originalConfig.contentUrl);\n  }\n  \n  return {\n    json: mergedData,\n    success: isSuccess\n  };\n});\n\n// Separate successful and failed uploads\nconst successful = results.filter(r => r.success);\nconst failed = results.filter(r => !r.success);\n\nconsole.log(`üìä UPLOAD SUMMARY:`);\nconsole.log(`  Successful: ${successful.length}`);\nconsole.log(`  Failed: ${failed.length}`);\n\nif (successful.length > 0) {\n  console.log('‚úÖ Sending successful uploads with original data preserved to Log Success');\n  return successful.map(r => ({ json: r.json }));\n} else {\n  console.log('‚ùå No successful uploads - sending to error handling');\n  return failed.map(r => ({ json: r.json }));\n}"
      },
      "id": "check-upload-success",
      "name": "Check Upload Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-400, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.cloudinary.com/v1_1/{{ $json.cloudName }}/auto/upload",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "file",
              "inputDataFieldName": "data"
            },
            {
              "name": "upload_preset",
              "value": "n8n_unsigned"
            },
            {
              "name": "public_id",
              "value": "={{ $json.publicId }}"
            },
            {
              "name": "folder",
              "value": "={{ $json.cloudinaryFolder }}"
            },
            {
              "name": "tags",
              "value": "=elevenlabs,v3-alpha,audio,{{ $json.speaker.toLowerCase() }}"
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "upload-to-cloudinary",
      "name": "Upload to Cloudinary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-600, 300],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Pass through all input items with proper binary data preservation and filename\nreturn $input.all().map(item => {\n  // Safety check for fileName\n  const fileName = item.json.fileName || 'unknown.wav';\n  const fileNameWithoutExt = fileName.replace('.wav', '');\n  \n  // Check if we have valid binary data\n  if (!item.binary || !item.binary.data) {\n    console.error(`‚ùå No binary audio data found for ${fileName}`);\n    console.error('This usually means ElevenLabs API returned an error instead of audio');\n    console.error('Check: API key, voice ID, quota, and request format');\n    \n    return {\n      json: {\n        ...item.json,\n        error: 'No binary audio data - ElevenLabs API may have failed',\n        fileName: fileName,\n        publicId: `${item.json.cloudinaryFolder}/${fileNameWithoutExt}`,\n        uploadReady: false\n      }\n    };\n  }\n  \n  // Validate binary data integrity to prevent contamination\n  const audioSize = item.binary.data.length;\n  const isValidAudio = audioSize > 1000; // Audio files should be larger than 1KB\n  \n  console.log(`‚úÖ Binary audio data found for ${fileName}`);\n  console.log(`üìä Audio size: ${Math.round(audioSize / 1024)} KB`);\n  \n  if (!isValidAudio) {\n    console.warn(`‚ö†Ô∏è Audio file ${fileName} seems too small (${audioSize} bytes) - possible corruption`);\n  }\n  \n  return {\n    json: {\n      ...item.json,\n      publicId: `${item.json.cloudinaryFolder}/${fileNameWithoutExt}`,\n      uploadReady: true,\n      audioSize: audioSize,\n      // Add execution timestamp to track freshness\n      generatedAt: new Date().toISOString()\n    },\n    binary: {\n      data: {\n        ...item.binary.data,\n        fileName: fileName,\n        mimeType: 'audio/mpeg'\n      }\n    }\n  };\n});"
      },
      "id": "prepare-for-upload",
      "name": "Prepare for Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-800, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "audio-success",
              "leftValue": "={{ $json.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "empty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-audio-generation",
      "name": "Check Audio Generation",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-1000, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://api.elevenlabs.io/v1/text-to-speech/{{ $json.voiceId }}?output_format={{ $json.responseFormat || 'mp3_44100_128' }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.elevenlabsPayload }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          },
          "timeout": 60000
        }
      },
      "id": "generate-audio",
      "name": "Generate Audio",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-1200, 300],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "credentials": {
        "httpHeaderAuth": {
          "id": "elevenlabs-auth",
          "name": "ElevenLabs API Auth"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Process ALL items, not just the first one\nconst allItems = $input.all();\n\nconsole.log(`üéôÔ∏è Processing ElevenLabs payloads for ${allItems.length} items`);\n\n// Helper function to snap stability to required values: 0.0, 0.5, 1.0\nconst snapStability = (value) => {\n  if (value <= 0.25) return 0.0;  // Creative\n  if (value <= 0.75) return 0.5;  // Natural  \n  return 1.0;                     // Robust\n};\n\n// Process each item and build ElevenLabs payload\nreturn allItems.map((item, index) => {\n  const current = item.json;\n  \n  console.log(`üéôÔ∏è Item ${index + 1}/${allItems.length}: ${current.fileName}`);\n  console.log(`üë§ Speaker: ${current.speaker}`);\n  console.log(`üìù Text: ${current.text.substring(0, 100)}...`);\n  console.log(`üéØ Voice ID: ${current.voiceId}`);\n  console.log(`üöÄ Model: ${current.modelId}`);\n  console.log(`üìä Item ${current.itemIndex}/${current.totalItems} in batch ${current.currentBatch}/${current.totalBatches}`);\n  \n  // Build ElevenLabs API payload with required stability values\n  const payload = {\n    text: current.text,\n    model_id: current.modelId || 'eleven_turbo_v2_5',\n    voice_settings: {\n      stability: snapStability(current.voiceSettings?.stability || 0.5),\n      similarity_boost: Math.min(Math.max(current.voiceSettings?.similarityBoost || 0.7, 0.0), 1.0),\n      style: Math.min(Math.max(current.voiceSettings?.style || 0.0, 0.0), 1.0),\n      use_speaker_boost: current.voiceSettings?.useSpeakerBoost !== undefined ? current.voiceSettings.useSpeakerBoost : true\n    }\n  };\n  \n  console.log(`üöÄ ElevenLabs payload prepared for ${current.speaker}:`);\n  console.log(`   Model: ${payload.model_id}`);\n  console.log(`   Voice settings: ${JSON.stringify(payload.voice_settings)}`);\n  console.log(`   Stability snapped to: ${payload.voice_settings.stability} (0.0=Creative, 0.5=Natural, 1.0=Robust)`);\n  \n  return {\n    json: {\n      ...current,\n      elevenlabsPayload: payload\n    }\n  };\n});"
      },
      "id": "build-elevenlabs-payload",
      "name": "Build ElevenLabs Payload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1400, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.contentUrl }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "fetch-remote-json",
      "name": "Fetch Remote JSON",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-1600, 300]
    },
    {
      "parameters": {
        "jsCode": "const config = $input.item.json;\n\n// Clear any potential state contamination\nconsole.log('üßπ Clearing workflow state for fresh execution');\nconsole.log('üì§ Passing configuration to Fetch Remote JSON:');\nconsole.log('üîç Full config object:', JSON.stringify(config, null, 2));\nconsole.log(`   Content URL: ${config.contentUrl}`);\nconsole.log(`   Max Items: ${config.maxItems}`);\nconsole.log(`   Start Index: ${config.startIndex}`);\nconsole.log(`   Execution ID: ${new Date().getTime()}`);\n\n// Safety check for contentUrl\nif (!config.contentUrl) {\n  console.error('‚ùå CRITICAL ERROR: contentUrl is undefined!');\n  console.error('üìã Available config keys:', Object.keys(config));\n  throw new Error('contentUrl is required for Fetch Remote JSON but was undefined. Check Setup Next Batch or Set Configuration nodes.');\n}\n\n// Verify URL format\nif (!config.contentUrl.startsWith('http')) {\n  console.error(`‚ùå INVALID URL FORMAT: ${config.contentUrl}`);\n  throw new Error('contentUrl must be a valid HTTP/HTTPS URL');\n}\n\nconsole.log('‚úÖ Configuration validation passed');\nreturn $input.all();"
      },
      "id": "pass-config-to-fetch",
      "name": "Pass Config to Fetch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1800, 300]
    },
    {
      "parameters": {
        "jsCode": "console.log('üåê Processing v3 Alpha remote content');\nconsole.log('üîê Using v3 Alpha model with Audio Tags support');\n\n// DEBUG: Check all available data sources\nconsole.log('üîç DEBUG: Available data sources:');\nconsole.log('  $json keys:', Object.keys($json));\nconsole.log('  $input.all().length:', $input.all().length);\nif ($input.all().length > 0) {\n  console.log('  $input.first().json keys:', Object.keys($input.first().json || {}));\n}\n\n// Get the remote JSON data and configuration from input context\nconst remoteData = $json;\n\n// TRY MULTIPLE CONFIG SOURCES\nlet config;\ntry {\n  // Method 1: Reference previous node (original approach)\n  config = $('Pass Config to Fetch').item.json;\n  console.log('‚úÖ Got config from node reference');\n} catch (error) {\n  console.log('‚ùå Node reference failed:', error.message);\n  // Method 2: Use input data\n  config = $input.first()?.json;\n  console.log('üîÑ Trying input reference instead');\n}\n\nconsole.log('üîç DEBUG: Config object:');\nconsole.log('  config exists:', !!config);\nif (config) {\n  console.log('  config keys:', Object.keys(config));\n  console.log('  contentUrl:', config.contentUrl);\n  console.log('  maxItems:', config.maxItems);\n  console.log('  startIndex:', config.startIndex);\n}\n\n// Validate config\nif (!config) {\n  console.error('‚ùå CRITICAL: No config found from any source!');\n  throw new Error('Configuration not found. Check data flow from Pass Config to Fetch node.');\n}\n\nif (!config.contentUrl) {\n  console.error('‚ùå CRITICAL: contentUrl missing from config!');\n  console.error('üìã Available config:', JSON.stringify(config, null, 2));\n  throw new Error('contentUrl is required but missing from configuration data.');\n}\n\nconst maxItems = config.maxItems || 5;\nconst startIndex = config.startIndex || 0;\nconst victorVoiceId = config.victorVoiceId;\nconst lennyVoiceId = config.lennyVoiceId;\nconst cloudinaryFolder = config.cloudinaryFolder;\nconst cloudName = config.cloudName;\n\nconsole.log('üìä Max items per batch:', maxItems);\nconsole.log('üéØ Starting from index:', startIndex);\nconsole.log('‚úÖ Successfully received v3 Alpha remote JSON');\n\n// Extract content array\nlet contentItems;\nif (Array.isArray(remoteData)) {\n  contentItems = remoteData;\n  console.log('üìã Content is direct array');\n} else if (remoteData.content && Array.isArray(remoteData.content)) {\n  contentItems = remoteData.content;\n  console.log('üìã Content found in .content property');\n} else {\n  console.error('‚ùå Invalid remote JSON format - no content array found');\n  throw new Error('Remote JSON must be array or object with content array');\n}\n\nconsole.log(`üìö Total content items available: ${contentItems.length}`);\n\n// Get default settings from remote data\nconst defaultSettings = remoteData.defaultSettings || {};\nconst voiceMapping = remoteData.voiceMapping || {};\n\n// Apply rate limiting - only process maxItems at a time\nconst endIndex = Math.min(startIndex + maxItems, contentItems.length);\nconst selectedLines = contentItems.slice(startIndex, endIndex);\nconst totalBatches = Math.ceil(contentItems.length / maxItems);\nconst currentBatch = Math.floor(startIndex / maxItems) + 1;\n\nconsole.log(`üìä Processing v3 Alpha batch ${currentBatch}/${totalBatches}: lines ${startIndex + 1} to ${endIndex}`);\n\nif (selectedLines.length === 0) {\n  console.warn('‚ö†Ô∏è No lines selected! All processing complete.');\n  return [];\n}\n\nif (endIndex < contentItems.length) {\n  console.log(`üìã Remaining lines after this batch: ${contentItems.length - endIndex}`);\n  console.log(`üîÑ Will automatically continue to next batch`);\n} else {\n  console.log('‚úÖ This is the final batch');\n}\n\nconsole.log('üîç DEBUG: Creating originalConfig with:');\nconsole.log('  contentUrl:', config.contentUrl);\nconsole.log('  victorVoiceId:', victorVoiceId);\nconsole.log('  maxItems:', maxItems);\n\n// Create individual items for processing with loop control data (preserving known good pattern)\nreturn selectedLines.map((line, index) => {\n  // Safety check for fileName\n  const fileName = line.fileName || 'unknown.wav';\n  const fileNameWithoutExt = fileName.replace('.wav', '');\n  \n  return {\n    json: {\n      ...line, // Preserve all original fields including Audio Tags\n      voiceId: line.voiceId || voiceMapping[line.speaker] || (line.speaker === 'Victor' ? victorVoiceId : lennyVoiceId),\n      cloudinaryFolder: cloudinaryFolder,\n      cloudName: cloudName,\n      itemIndex: index + 1,\n      totalItems: selectedLines.length,\n      batchStartIndex: startIndex,\n      globalIndex: startIndex + index + 1,\n      totalContentItems: contentItems.length,\n      currentBatch: currentBatch,\n      totalBatches: totalBatches,\n      publicId: `${cloudinaryFolder}/${fileNameWithoutExt}`,\n      // Loop control data\n      nextStartIndex: endIndex,\n      hasMoreBatches: endIndex < contentItems.length,\n      originalConfig: {\n        contentUrl: config.contentUrl,\n        victorVoiceId: victorVoiceId,\n        lennyVoiceId: lennyVoiceId,\n        cloudinaryFolder: cloudinaryFolder,\n        cloudName: cloudName,\n        maxItems: maxItems\n      }\n    }\n  };\n});"
      },
      "id": "process-remote-content-v3-alpha",
      "name": "Process Remote Content (v3 Alpha)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1400, 100]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "content-url",
              "name": "contentUrl",
              "value": "https://raw.githubusercontent.com/velocitystar/N8N-Workflows/main/docs/distortion-check-v3-alpha-test.json",
              "type": "string"
            },
            {
              "id": "victor-voice",
              "name": "victorVoiceId",
              "value": "T9xTMubBGC4Y9y6oHUza",
              "type": "string"
            },
            {
              "id": "lenny-voice",
              "name": "lennyVoiceId",
              "value": "WbI4Toj5UDP91WAiEInp",
              "type": "string"
            },
            {
              "id": "cloudinary-folder",
              "name": "cloudinaryFolder",
              "value": "elevenlabs-audio/v3-alpha-test",
              "type": "string"
            },
            {
              "id": "cloudinary-cloud-name",
              "name": "cloudName",
              "value": "dly199qqv",
              "type": "string"
            },
            {
              "id": "rate-limit",
              "name": "maxItems",
              "value": 2,
              "type": "number"
            },
            {
              "id": "start-index",
              "name": "startIndex",
              "value": 0,
              "type": "number"
            }
          ]
        },
        "options": {}
      },
      "id": "set-configuration",
      "name": "Set Configuration",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [-2000, 300]
    },
    {
      "parameters": {},
      "id": "start",
      "name": "Start",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [-2200, 300]
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": 3
      },
      "id": "wait-3-seconds",
      "name": "Wait 3 seconds",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [200, -400]
    }
  ],
  "pinData": {},
  "connections": {
    "Batch Completion Check": {
      "main": [
        [
          {
            "node": "More Batches?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug False Path": {
      "main": [
        [
          {
            "node": "Final Completion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Setup Next Batch": {
      "main": [
        [
          {
            "node": "Pass Config to Fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug True Path": {
      "main": [
        [
          {
            "node": "Wait 3 seconds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "More Batches?": {
      "main": [
        [
          {
            "node": "Debug True Path",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Debug False Path",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug More Batches": {
      "main": [
        [
          {
            "node": "Final Completion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Success": {
      "main": [
        [
          {
            "node": "Batch Completion Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Upload Success": {
      "main": [
        [
          {
            "node": "Log Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Cloudinary": {
      "main": [
        [
          {
            "node": "Check Upload Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for Upload": {
      "main": [
        [
          {
            "node": "Upload to Cloudinary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Audio Generation": {
      "main": [
        [
          {
            "node": "Prepare for Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Audio": {
      "main": [
        [
          {
            "node": "Check Audio Generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build ElevenLabs Payload": {
      "main": [
        [
          {
            "node": "Generate Audio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Remote JSON": {
      "main": [
        [
          {
            "node": "Process Remote Content (v3 Alpha)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pass Config to Fetch": {
      "main": [
        [
          {
            "node": "Fetch Remote JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Remote Content (v3 Alpha)": {
      "main": [
        [
          {
            "node": "Build ElevenLabs Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Configuration": {
      "main": [
        [
          {
            "node": "Pass Config to Fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Start": {
      "main": [
        [
          {
            "node": "Set Configuration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 3 seconds": {
      "main": [
        [
          {
            "node": "Setup Next Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "",
    "timezone": "America/New_York"
  },
  "versionId": "1",
  "meta": {
    "instanceId": "fixed-v3-alpha-workflow"
  },
  "id": "distortion-check-v3-alpha-fixed",
  "tags": []
}
